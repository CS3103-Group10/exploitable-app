# Tutor Walkthrough

# Scenario

**_Flora_** is an online game portal where various in-game items are available for purchase with _Asiv_ credits.

**_Asiv_ credits** are online currency units managed by a third-party provider called _Asiv_. _Asiv_ credits are sold in exchange for real life currency at a fixed rate.

To complicate things, _Flora_ requires a **paid sign-up fee** in order to create an account as each account comes with a start-up bonus of 10 credits, so the online _Flora_ portal does not provide a way for new users to create an account.

However, _Flora_ and _Asiv_ have been intentionally implemented to have security vulnerabilities in order for students to exploit with the challenge of buying inordinate number of items in order to destabilize the in-game economy.

## Setup
Ensure students are able to follow the README and launch the server and client without issue. Students who forget to launch either of the services may face issues.

Ensure that students understand the following cyber attacks:
- SQL injection
- HTTP packet sniffing for compromised plaintext API keys
- Making fraudulent HTTP requests

Where possible, also ensure that students do not have access to the repository or this walkthrough directly. They are given their own walkthrough (`StudentWalkthrough.md`).

## Deliverables
Ensure that students show adequate understanding in their responses. If their explanations do not make sense, it is likely that they have not fully understood how the attacks work.

It is also possible that they have followed the rules and found a different vulnerability that we did not expect. In this case, we implore that flexibility be taken as the main objective for this exercise is simply to showcase that modern web applications and frameworks can still have often simple exploitable vulnerabilities.

---

## Task 1 - Breaking into an account
This task is a classic example of an **SQL injection** attack. Students are tested on their understanding of how SQL injections work and how middleware can fail to sanitize user inputs.

Students can simply input any username and enter the following into the password field:
```
x' OR 1=1; --
```

Students may even choose to create a account altogether with a statement similar to:
```
1'; INSERT INTO Users values ('kappa', '123');--
```
, which would create a new account "kappa" with the password "123".

This would be a reasonable assumption to make that developers would store user account information in a generic table name like "Users" and have a schema like Username and Password as contiguous columns.

> It is worth noting that for a User entity, the credit balance and the id of the user are both default 0 and serial respectively, so specifying them would not be necessary in on an insert statement)

To prevent SQL injections of this nature, a variety of methods can be used, such as:
* Prepared Statements - Pre-optimized and pre-formatted query templates stored on the DB beforehand
* Sanitizing Input - Properly escaping or removing characters where necessary

---

## Task 2 - Finding the API key

For this task, students are supposed to determine the API key used for interactions with the _Asiv_ online currency provider. To achieve this, there are two ways that we have designed this for students to discover.

1. **The API key is determined from unobscured source code.**
   
   <img alt="API key in client source code" src="https://raw.githubusercontent.com/exploitable-app/main/preview/floraApiKey1.png" width="80%"/>
   
   As you can see the key is easily retrieved as it remains in the source code in plaintext. More importantly, it is present in the frontend web application, which should never be the case for secrets. (Much less an API key managing payments.)

2. **The key is determined by examining the outgoing HTTP request sent by the client web application during a transaction.**
   
   <img alt="API key in HTTP request" src="https://raw.githubusercontent.com/exploitable-app/main/preview/floraApiKey2.png" width="80%"/>

   Alternatively, you can see that the key is also shown in plaintext in the outgoing request payload towards the _Asiv_ server.

This task basically emphasizes the importance of not storing API keys that are not meant for the user to own directly in the web application. It should be assumed that all API keys and all other information stored on client served applications will be exposed publicly to the user. Thus, keys that are secret should be contained entirely within the _Flora's_ server and never exposed to the user.

---

## Task 3 - Making a fraudulent purchase

The final task basically completes the attack by having the students send tampered HTTP requests to the _Asiv_ server directly. During this task, students should be able to demonstrate their understanding of HTTP requests (Request type, payload format, target address) and using Postman to send HTTP requests of their own design.

First, they can simply observe the _Asiv_ server endpoint URL from the Network tab upon attempting to buy a product:

<img alt="Target Address in HTTP request" src="https://raw.githubusercontent.com/exploitable-app/main/preview/targetAddress.png" width="60%"/>

The schema for the request body is also shown in the HTTP request payload section, as seen previously if they had attempted to find the API key via the DevTools Network tab.

<img alt="Asiv Purchase Payload" src="https://raw.githubusercontent.com/exploitable-app/main/preview/apiPayload.png" width="60%"/>

Then, they can deduce that the JSON parameters in the payload refers to the API key (`API_KEY`), product cost in _Asiv_ credits (`pcost`), product ID (`pid`) and their account user ID (`uid`).

Knowing this, they can now use Postman to create a customized POST HTTP request, buying the most expensive item (_Extinction Mirror_ - Product ID `5`) for a cost of `0`:

<img alt="Postman POST Request" src="https://raw.githubusercontent.com/exploitable-app/main/preview/postman.png" width="80%"/>

Which, returns a link for the secure _Asiv_ confirmation page. Accessing the page and confirming the purchase then results in the item being added to the inventory of the user.

---

## Improving the application design for Task 2 and 3
To make it easier to visualize what is happening, we can depict the communication between the client and the servers using a sequence diagram.

<img alt="Flawed Workflow" src="https://raw.githubusercontent.com/exploitable-app/main/preview/flawedFlow.png" width="100%"/>

As you can see, the main issue is that the API key is stored in the frontend application and is used to directly communicate with the _Asiv_ server.

Thus, an immediate improvement to the design would be to have the client application **talk to the _Flora_ server first**, which would then use its API key to talk to _Asiv_.

<img alt="Correct Workflow" src="https://raw.githubusercontent.com/exploitable-app/main/preview/correctFlow.png" width="100%"/>

We can further improve this design by having the frontend application only specify the product ID and the user ID, keeping the cost untampered and maintained entirely within the _Flora_ server.

<img alt="Improved Workflow" src="https://raw.githubusercontent.com/exploitable-app/main/preview/improvedFlow.png" width="100%"/>

